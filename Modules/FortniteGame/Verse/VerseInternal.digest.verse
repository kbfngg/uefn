# Copyright Epic Games, Inc. All Rights Reserved.
#################################################
# Generated Digest of Verse API
# DO NOT modify this manually!
# Generated from build: ++Fortnite+Release-32.10-CL-37958378
#################################################

using { /Verse.org/ParameterCollections }
using { /Verse.org/Restricted }
using { /Verse.org/VerseEngine }
# Module import path: /Verse.org/Assets
Assets<public> := module {
  # Create an asset reference to the given internal asset path
  MakeAsset<native><epic_internal>(AssetType: type, AssetPath: string)<converges>: AssetType

  animation<native><epic_internal> := class<computes><final><epic_internal>(asset) {}

  animation_blueprint<native><epic_internal> := class<computes><final><epic_internal>(asset) {}

  animation_instance<native><epic_internal> := class<computes><final><epic_internal>(asset) {}

  animation_sequence<native><public> := class<computes><concrete><final><epic_internal>(asset) {}

  asset<native><epic_internal> := class<computes><epic_internal> {
    Async_Load<native><epic_internal>(): sticky_event(void)

    GetAssetType<native><epic_internal>()<transacts><decides>: type

    GetAsyncLoadEvent<native><epic_internal>()<decides>: sticky_event(void)

    SyncLoad<native><epic_internal>(): logic
  }

  camera_rig_asset<native><epic_internal> := class<computes><concrete><epic_internal>(asset) {}

  camera_variable_float<native><epic_internal> := class<computes><concrete><epic_internal>(asset) {}

  camera_variable_integer<native><epic_internal> := class<computes><concrete><epic_internal>(asset) {}

  camera_variable_logic<native><epic_internal> := class<computes><concrete><epic_internal>(asset) {}

  camera_variable_rotation<native><epic_internal> := class<computes><concrete><epic_internal>(asset) {}

  camera_variable_transform<native><epic_internal> := class<computes><concrete><epic_internal>(asset) {}

  camera_variable_vector2<native><epic_internal> := class<computes><concrete><epic_internal>(asset) {}

  camera_variable_vector3<native><epic_internal> := class<computes><concrete><epic_internal>(asset) {}

  client_asset<native><epic_internal> := class<abstract><computes><epic_internal>(asset) {}

  font<native><epic_internal> := class<computes><concrete><final><epic_internal>(client_asset) {}

  input_action<native><epic_internal>(t: type) := class<computes><concrete><epic_internal>(asset) {
    Path<native><public>: string = external {}
  }

  input_mapping<native><epic_internal> := class<computes><concrete><epic_internal>(asset) {}

  level<native><epic_internal> := class<computes><final><epic_internal>(asset) {}

  material<native><public> := interface<epic_internal> {
    GetAsset<native_callable><epic_internal>(): material_asset

    GetMaterialInterface<native_callable><epic_internal>(): ue_material_interface
  }

  material_asset<native><epic_internal> := class<final><epic_internal>(material, asset) {
    GetAsset<override>(): material_asset = external {}

    GetMaterialInterface<native><override>(): ue_material_interface
  }

  mesh<native><public> := class<computes><concrete><epic_internal>(asset) {}

  # The UClass generated by the ParameterCollection asset. It represents the parameter_collection verse class but with UE5 properties.
  parameter_collection_UE5_definition<native><epic_internal> := class<computes><final>(asset) {}

  parameterized_material<native><epic_internal> := class<epic_internal>(material, parameter_collection) {
    GetAsset<override>(): material_asset = external {}

    GetMaterialInterface<native><override>(): ue_material_interface

    Material<native><epic_internal>: (/Verse.org/Assets:)material
  }

  # parameter_collection that will be generated in the digest from the Editable
  parameterized_parameter_collection<native><epic_internal> := class<unique>(parameter_collection) {
    UE5Class<native><epic_internal>: parameter_collection_UE5_definition
  }

  particle_system<native><public> := class<computes><concrete><final><epic_internal>(client_asset) {}

  skeletal_mesh<native><epic_internal> := class<computes><concrete><final><epic_internal>(mesh) {}

  sound<native><epic_internal> := class<computes><concrete><final><epic_internal>(client_asset) {}

  texture<native><public> := class<computes><final><epic_internal>(texture_base) {}

  texture_base<native><epic_internal> := class<computes><epic_internal>(asset) {}

  @import_as("/Script/Engine.UMaterialInterface")
  ue_material_interface<native><epic_internal> := class {}
}

# Module import path: /Verse.org/Colors
Colors<public> := module {
  # Makes an ACES 2065-1 `color` from `Hue`, `Saturation`, and `Value` components.
  # Components use the HSV color model in the sRGB color space. Expected ranges:
  #  * `0.0 <= Hue <= 360.0`
  #  * `0.0 <= Saturation <= 1.0`
  #  * `0.0 <= Value <= 1.0`
  # Values out of expected ranges will undergo range reduction and conversion.
  MakeColorFromHSV<native><public>(Hue: float, Saturation: float, Value: float)<converges>: color

  # Makes an ACES 2065-1 `color` from a CSS-style sRGB `hexString`. Supported formats are:
  #  * RGB
  #  * RRGGBB
  #  * RRGGBBAA
  #  * #RGB
  #  * #RRGGBB
  #  * #RRGGBBAA
  # An invalid hex string will return `Black`.
  MakeColorFromHex<native><public>(hexString: string)<converges>: color

  # Makes an ACES 2065-1 `color` from sRGB components `Red`, `Green`, and `Blue`.
  # Normal sRGB component values are between `0.0` and `1.0`, but this can handle larger values.
  MakeColorFromSRGB<native><public>(Red: float, Green: float, Blue: float)<converges>: color

  # Makes an ACES 2065-1 `color` from the integer sRGB components `Red`, `Green`, and `Blue`.
  # Valid sRGB component values are between '0' and '255', inclusive.
  MakeColorFromSRGBValues<native><public>(Red: int, Green: int, Blue: int)<converges>: color

  # Makes an ACES 2065-1 `color` from the chromaticity of a blackbody radiator at `Temperature` Kelvin.
  # `Temperature` is clamped such that `0 <= Temperature`.
  MakeColorFromTemperature<native><public>(Temperature: float)<converges>: color

  # Makes an HSV `tuple` by converting `InColor` from an ACES 2065-1 `color` to sRGB and applying the HSV color model.
  MakeHSVFromColor<native><public>(InColor: color): tuple(float, float, float)

  # Makes an sRGB `tuple` by converting `InColor` from an ACES 2065-1 `color` to sRGB.
  MakeSRGBFromColor<native><public>(InColor: color)<converges>: tuple(float, float, float)

  # Module import path: /Verse.org/Colors/NamedColors
  # Color presets from CSS Color Module 3 Extended color keywords.
  NamedColors<public> := module {
    (/Verse.org/Colors/NamedColors:)Tan<public>: color = external {}

    AliceBlue<public>: color = external {}

    AntiqueWhite<public>: color = external {}

    Aqua<public>: color = external {}

    Aquamarine<public>: color = external {}

    Azure<public>: color = external {}

    Beige<public>: color = external {}

    Bisque<public>: color = external {}

    Black<public>: color = external {}

    BlanchedAlmond<public>: color = external {}

    Blue<public>: color = external {}

    BlueViolet<public>: color = external {}

    Brown<public>: color = external {}

    Burlywood<public>: color = external {}

    CadetBlue<public>: color = external {}

    Chartreuse<public>: color = external {}

    Chocolate<public>: color = external {}

    Coral<public>: color = external {}

    CornflowerBlue<public>: color = external {}

    Cornsilk<public>: color = external {}

    Crimson<public>: color = external {}

    Cyan<public>: color = external {}

    DarkBlue<public>: color = external {}

    DarkCyan<public>: color = external {}

    DarkGoldenrod<public>: color = external {}

    DarkGray<public>: color = external {}

    DarkGreen<public>: color = external {}

    DarkGrey<public>: color = external {}

    DarkKhaki<public>: color = external {}

    DarkMagenta<public>: color = external {}

    DarkOliveGreen<public>: color = external {}

    DarkOrange<public>: color = external {}

    DarkOrchid<public>: color = external {}

    DarkRed<public>: color = external {}

    DarkSalmon<public>: color = external {}

    DarkSeaGreen<public>: color = external {}

    DarkSlateBlue<public>: color = external {}

    DarkSlateGray<public>: color = external {}

    DarkSlateGrey<public>: color = external {}

    DarkTurquoise<public>: color = external {}

    DarkViolet<public>: color = external {}

    DeepPink<public>: color = external {}

    DeepSkyBlue<public>: color = external {}

    DimGray<public>: color = external {}

    DimGrey<public>: color = external {}

    DodgerBlue<public>: color = external {}

    Firebrick<public>: color = external {}

    FloralWhite<public>: color = external {}

    ForestGreen<public>: color = external {}

    Fuchsia<public>: color = external {}

    Gainsboro<public>: color = external {}

    GhostWhite<public>: color = external {}

    Gold<public>: color = external {}

    Goldenrod<public>: color = external {}

    Gray<public>: color = external {}

    Green<public>: color = external {}

    GreenYellow<public>: color = external {}

    Grey<public>: color = external {}

    Honeydew<public>: color = external {}

    Hotpink<public>: color = external {}

    IndianRed<public>: color = external {}

    Indigo<public>: color = external {}

    Ivory<public>: color = external {}

    Khaki<public>: color = external {}

    Lavender<public>: color = external {}

    LavenderBlush<public>: color = external {}

    LawnGreen<public>: color = external {}

    LemonChiffon<public>: color = external {}

    LightBlue<public>: color = external {}

    LightCoral<public>: color = external {}

    LightCyan<public>: color = external {}

    LightGoldenrodYellow<public>: color = external {}

    LightGray<public>: color = external {}

    LightGreen<public>: color = external {}

    LightGrey<public>: color = external {}

    LightPink<public>: color = external {}

    LightSalmon<public>: color = external {}

    LightSeaGreen<public>: color = external {}

    LightSkyBlue<public>: color = external {}

    LightSlateGray<public>: color = external {}

    LightSlateGrey<public>: color = external {}

    LightSteelBlue<public>: color = external {}

    LightYellow<public>: color = external {}

    Lime<public>: color = external {}

    LimeGreen<public>: color = external {}

    Linen<public>: color = external {}

    Magenta<public>: color = external {}

    Maroon<public>: color = external {}

    MediumAquamarine<public>: color = external {}

    MediumBlue<public>: color = external {}

    MediumOrchid<public>: color = external {}

    MediumPurple<public>: color = external {}

    MediumSeaGreen<public>: color = external {}

    MediumSlateBlue<public>: color = external {}

    MediumSpringGreen<public>: color = external {}

    MediumTurquoise<public>: color = external {}

    MediumVioletRed<public>: color = external {}

    MidnightBlue<public>: color = external {}

    MintCream<public>: color = external {}

    MistyRose<public>: color = external {}

    Moccasin<public>: color = external {}

    NavajoWhite<public>: color = external {}

    Navy<public>: color = external {}

    OldLace<public>: color = external {}

    Olive<public>: color = external {}

    OliveDrab<public>: color = external {}

    Orange<public>: color = external {}

    OrangeRed<public>: color = external {}

    Orchid<public>: color = external {}

    PaleGoldenrod<public>: color = external {}

    PaleGreen<public>: color = external {}

    PaleTurquoise<public>: color = external {}

    PaleVioletred<public>: color = external {}

    PapayaWhip<public>: color = external {}

    PeachPuff<public>: color = external {}

    Peru<public>: color = external {}

    Pink<public>: color = external {}

    Plum<public>: color = external {}

    PowderBlue<public>: color = external {}

    Purple<public>: color = external {}

    Red<public>: color = external {}

    RosyBrown<public>: color = external {}

    RoyalBlue<public>: color = external {}

    SaddleBrown<public>: color = external {}

    Salmon<public>: color = external {}

    SandyBrown<public>: color = external {}

    SeaGreen<public>: color = external {}

    SeaShell<public>: color = external {}

    Sienna<public>: color = external {}

    Silver<public>: color = external {}

    SkyBlue<public>: color = external {}

    SlateBlue<public>: color = external {}

    SlateGray<public>: color = external {}

    SlateGrey<public>: color = external {}

    Snow<public>: color = external {}

    SpringGreen<public>: color = external {}

    SteelBlue<public>: color = external {}

    Teal<public>: color = external {}

    Thistle<public>: color = external {}

    Tomato<public>: color = external {}

    Turquoise<public>: color = external {}

    Violet<public>: color = external {}

    Wheat<public>: color = external {}

    White<public>: color = external {}

    WhiteSmoke<public>: color = external {}

    Yellow<public>: color = external {}

    YellowGreen<public>: color = external {}
  }

  # Represents colors as RGB triples in the ACES 2065-1 color space.
  # Component values are linear (i.e. `*gamma* = 1.0`).
  color<native><public> := struct<concrete><computes><persistable> {
    @editable
    # Blue component of this `color`.
    B<native><public>: float = external {}

    @editable
    # Green component of this `color`.
    G<native><public>: float = external {}

    @editable
    # Red component of this `color`.
    R<native><public>: float = external {}
  }

  # Makes an ACES 2065-1 `color` from the component-wise product of `c0` and `c1`.
  operator'*'<native><public>(c0: color, c1: color)<converges>: color

  # Makes an ACES 2065-1 `color` from each component of `c` scaled by `factor`.
  operator'*'<native><public>(c: color, factor: float)<converges>: color

  # Makes an ACES 2065-1 `color` from each component of `c` scaled by `factor`.
  operator'*'<native><public>(c: color, factor: int)<converges>: color

  # Makes an ACES 2065-1 `color` from each component of `c` scaled by `factor`.
  operator'*'<native><public>(factor: float, c: color)<converges>: color

  # Makes an ACES 2065-1 `color` from each component of `c` scaled by `factor`.
  operator'*'<native><public>(factor: int, c: color)<converges>: color

  # Makes an ACES 2065-1 `color` from the component-wise sum of `c0` and `c1`.
  operator'+'<native><public>(c0: color, c1: color)<converges>: color

  # Makes an ACES 2065-1 `color` from the component-wise difference of `c0` and `c1`.
  operator'-'<native><public>(c0: color, c1: color)<converges>: color

  # Makes an ACES 2065-1 `color` from each component of `c` divided by `factor`.
  operator'/'<native><public>(c: color, factor: float)<converges><decides>: color

  # Makes an ACES 2065-1 `color` from each component of `c` divided by `factor`.
  operator'/'<native><public>(c: color, factor: int)<converges><decides>: color
}

# Module import path: /Verse.org/Concurrency
Concurrency<public> := module {
  awaitable<public>() := awaitable(void)

  # A parametric interface implemented by events with a `payload` that can be waited on. Matched with `signalable.`
  awaitable<public>(payload: type) := interface {
    # Suspends the current task until resumed by a matching call to `signalable.Signal`. Returns the event `payload`.
    Await<public>()<suspends>: payload
  }

  task<native><public>(t: type) := class<abstract><final>(awaitable(t)) {
    Active<native><epic_internal>()<transacts><decides>: void

    Await<native><override>()<suspends>: t

    Cancel<native><epic_internal>()<suspends>: void

    Canceled<native><epic_internal>()<transacts><decides>: void

    Canceling<native><epic_internal>()<transacts><decides>: void

    Completed<native><epic_internal>()<transacts><decides>: void

    Interrupted<native><epic_internal>()<transacts><decides>: void

    Settled<native><epic_internal>()<transacts><decides>: void

    Uninterrupted<native><epic_internal>()<transacts><decides>: void

    Unsettled<native><epic_internal>()<transacts><decides>: void
  }
}

using { /UnrealEngine.com/Temporary/SpatialMath }
using { /Verse.org/Assets }
using { /Verse.org/Native }
using { /Verse.org/Simulation }
# Module import path: /Verse.org/ControlInput
ControlInput<public> := module {
  GetPlayerInput<native><epic_internal>(Player: player)<transacts><decides>: player_input

  # Module import path: /Verse.org/ControlInput/InputVerbs
  InputVerbs<epic_internal> := module {
    Crouch<epic_internal>: verb = external {}

    Emote<epic_internal>: verb = external {}

    Fire<epic_internal>: verb = external {}

    Jump<epic_internal>: verb = external {}

    LookUp<epic_internal>: verb = external {}

    MoveForward<epic_internal>: verb = external {}

    MoveRight<epic_internal>: verb = external {}

    MoveUp<epic_internal>: verb = external {}

    Reload<epic_internal>: verb = external {}

    Sprint<epic_internal>: verb = external {}

    Target<epic_internal>: verb = external {}

    Turn<epic_internal>: verb = external {}

    Use<epic_internal>: verb = external {}
  }

  MakeInputAsset<native><epic_internal>(t: type, InputAction: input_action(t), Path: string)<converges>: input_action(t)

  @import_as("/Script/VerseInput.UVerseInputClientActionVerbBase")
  action<native><epic_internal> := class<computes><abstract> {}

  apply_impulse_action<native><epic_internal> := class(action) {
    Impulse<native><epic_internal>: vector3
  }

  dead_zone<native><epic_internal> := class<computes>(modifier) {
    LowerThreshold<native><epic_internal>: float = external {}

    Type<native><epic_internal>: dead_zone_type = external {}

    UpperThreshold<native><epic_internal>: float = external {}
  }

  dead_zone_type<native><epic_internal> := enum {
    Axial

    Radial
  }

  down<native><epic_internal> := class<computes>(trigger) {
    ActuationThreshold<native><epic_internal>: float = external {}
  }

  exponential_response<native><epic_internal> := class<computes>(modifier) {
    CurveExponent<native><epic_internal>: vector3 = external {}
  }

  hold<native><epic_internal> := class<computes>(trigger) {
    ActuationThreshold<native><epic_internal>: float = external {}

    AffectedByTimeDilation<native><epic_internal>: logic = external {}

    HoldTimeThreshold<native><epic_internal>: float = external {}

    IsOneShot<native><epic_internal>: logic = external {}
  }

  hold_and_release<native><epic_internal> := class<computes>(trigger) {
    ActuationThreshold<native><epic_internal>: float = external {}

    AffectedByTimeDilation<native><epic_internal>: logic = external {}

    HoldTimeThreshold<native><epic_internal>: float = external {}
  }

  input_action_verb<native><epic_internal> := class<computes> {
    Actions<native><epic_internal>: []action

    ConsumeInput<native><epic_internal>: logic = external {}

    Modifiers<native><epic_internal>: []modifier = external {}

    Triggers<native><epic_internal>: []trigger

    Verb<native><epic_internal>: verb
  }

  input_events<native><public>(t: type) := class {
    ActivationCanceledEvent<native><public>: listenable(tuple(player, t, float)) = external {}

    ActivationTriggeredEvent<native><public>: listenable(tuple(player, t)) = external {}

    DetectionBeginEvent<native><public>: listenable(tuple(player, t)) = external {}

    DetectionEndEvent<native><public>: listenable(tuple(player, float)) = external {}

    DetectionOngoingEvent<native><public>: listenable(tuple(player, t, float)) = external {}
  }

  launch_action<native><epic_internal> := class(action) {
    Velocity<native><epic_internal>: vector3
  }

  modifier<native><epic_internal> := class<computes><abstract><epic_internal> {}

  negate<native><epic_internal> := class<computes>(modifier) {
    X<native><epic_internal>: logic = external {}

    Y<native><epic_internal>: logic = external {}

    Z<native><epic_internal>: logic = external {}
  }

  play_sound_action<native><epic_internal> := class(action) {
    Sound<native><epic_internal>: sound
  }

  player_input<native><epic_internal> := class {
    AddInputActionVerb<native><epic_internal>(InputActionVerb: input_action_verb): void

    AddInputMapping<native><public>(InputMapping: input_mapping): void

    GetInputEvents<native><public>(t: type, ActionToBind: input_action(t)): input_events(t)

    MakeFloatInputEvents<native_callable><epic_internal>(): input_events(float) = external {}

    MakeLogicInputEvents<native_callable><epic_internal>(): input_events(logic) = external {}

    MakeVector2InputEvents<native_callable><epic_internal>(): input_events(vector2) = external {}

    MakeVector3InputEvents<native_callable><epic_internal>(): input_events(vector3) = external {}

    RemoveInputActionVerb<native><epic_internal>(InputActionVerb: input_action_verb): void

    RemoveInputMapping<native><public>(InputMapping: input_mapping): void
  }

  pressed<native><epic_internal> := class<computes>(trigger) {
    ActuationThreshold<native><epic_internal>: float = external {}
  }

  released<native><epic_internal> := class<computes>(trigger) {
    ActuationThreshold<native><epic_internal>: float = external {}
  }

  scale<native><epic_internal> := class<computes>(modifier) {
    Scale<native><epic_internal>: vector3 = external {}
  }

  smooth<native><epic_internal> := class<computes>(modifier) {}

  spawn_particle_effect_action<native><epic_internal> := class(action) {
    ParticleSystem<native><epic_internal>: particle_system
  }

  swizzle<native><epic_internal> := class<computes>(modifier) {
    Order<native><epic_internal>: swizzle_order = external {}
  }

  swizzle_order<native><epic_internal> := enum {
    XZY

    YXZ

    YZX

    ZXY

    ZYX
  }

  tap<native><epic_internal> := class<computes>(trigger) {
    ActuationThreshold<native><epic_internal>: float = external {}

    AffectedByTimeDilation<native><epic_internal>: logic = external {}

    TapReleaseTimeThreshold<native><epic_internal>: float = external {}
  }

  trigger<native><epic_internal> := class<computes><abstract><epic_internal> {}

  verb<native><epic_internal> := class<computes><epic_internal> {
    InputNames<native><epic_internal>: []string

    IsAxis<native><epic_internal>: logic
  }
}

# Module import path: /Verse.org/Native
Native<public> := module {
  doc<constructor><epic_internal>(DocumentationString: string)<computes>: doc_attribute = external {}

  @attribscope_module
  @attribscope_class
  @attribscope_struct
  @attribscope_function
  @attribscope_data
  @attribscope_enum
  @attribscope_enumerator
  @attribscope_interface
  @attribscope_typedefinition
  doc_attribute<epic_internal> := class<computes><internal>(attribute) {}

  import_as<constructor><epic_internal>(ImportName: string)<computes>: import_as_attribute = external {}

  @attribscope_class
  @attribscope_struct
  import_as_attribute<epic_internal> := class<computes><internal>(attribute) {}

  validate_asset_path<constructor><epic_internal>(Modifiers: string)<computes>: validate_asset_path_attribute = external {}

  @attribscope_function
  @attribscope_data
  validate_asset_path_attribute<epic_internal> := class<computes><internal>(attribute) {}
}

# Module import path: /Verse.org/ParameterCollections
ParameterCollections<public> := module {
  parameter_collection<native><epic_internal> := class {
    OnPropertyChangedFromVerse<native><epic_internal>(StringParam: string)<transacts>: void
  }
}

# Module import path: /Verse.org/Random
Random<public> := module {
  # Returns a random `float` between `Low` and `High`, inclusive.
  GetRandomFloat<native><public>(Low: float, High: float)<transacts>: float

  # Returns a random `int` between `Low` and `High`, inclusive.
  GetRandomInt<native><public>(Low: int, High: int)<transacts>: int

  # Makes an `array` with the same elements as `Input` shuffled in a random order.
  Shuffle<public>(Input: []t where t: type)<transacts>: []t = external {}
}

using { /Verse.org/Concurrency }
# Module import path: /Verse.org/Restricted
Restricted<public> := module {
  sticky_event<native><public>(t: type) := class(signalable(t), awaitable(t)) {
    Await<native><override>()<suspends>: t

    ClearSignal<native><public>(): void

    GetAwaitCount<native><epic_internal>(): int

    IsSignaled<native><public>()<decides>: void

    Signal<native><override>(__dupe___unnamed_parameter_15: t): void
  }

  sticky_event<public>() := sticky_event(void)
}

Simulation<public> := module {
  # Returns the `session` corresponding to the current round.  The result can be used with `weak_map` to implement global variables.
  # Note: may be changed in a future release to return a single instance per game. Round-local behavior should not be relied upon.
  GetSession<native><public>()<computes><reads>: session

  # Get the seconds that have elapsed since the world began simulating
  GetSimulationElapsedTime<native><public>()<transacts>: float

  MakeLocalizableValue<epic_internal>(Agent: agent): localizable_agent = external {}

  # Waits specified number of seconds and then resumes. If `Seconds` = 0.0 then it waits until next tick/frame/update. If `Seconds` = Inf then it waits forever and only calls back if canceled - such as via `race`. If `Seconds` < 0.0 then it completes immediately and does not yield to other aysnc expressions.
  # Waiting until the next update (0.0) is especially useful in a loop of a coroutine that needs to do some work every update and this yields to other coroutines so that it doesn't hog a processor's resources.
  # Waiting forever (Inf) will have any expression that follows never be evaluated. Occasionally it is desireable to have a task never complete such as the last expression in a `race` subtask where the task must never win the race though it still may be canceled earlier.
  # Immediately completing (less than 0) is useful when you want programmatic control over whether an expression yields or not.
  Sleep<native><public>(Seconds: float)<suspends>: void

  using { /Verse.org/Native }
  # Module import path: /Verse.org/Simulation/Tags
  Tags<public> := module {
    # Succeeds if Left and Right are equal.
    Equals<native><epic_internal>(Left: tag, Right: tag)<transacts><decides>: void

    # Succeeds if all tags in Left are found in Right and all tags in Right are found in Left.
    Equals<native><epic_internal>(Left: tag_container, Right: tag_container)<transacts><decides>: void

    # Utility function to allow for easy construction from editor exposable tag_selector
    MakeTag<native><epic_internal>(Selector: tag_selector)<transacts><decides>: tag

    # Create a tag container from an array of gameplay_tag.
    MakeTagContainer<native><constructor><epic_internal>(InTags: []tag)<transacts>: tag_container

    # Utility function to allow for easy construction from editor exposable tag_selector_container
    MakeTagContainer<native><epic_internal>(Selector: tag_selector_container)<transacts><decides>: tag_container

    # Utility function to allow for easy construction from subclass
    MakeTagFromSubClass<native><epic_internal>(Type: subtype(tag))<transacts><decides>: tag

    # Get a string representation of the gameplay tag. Useful for debugging.
    ToString<native><epic_internal>(__dupe___unnamed_parameter_32: tag)<computes>: string

    # Returns abbreviated human readable Tag list. Useful for debugging.
    ToString<native><epic_internal>(__dupe___unnamed_parameter_35: tag_container)<computes>: string

    # A single gameplay tag, which represents a hierarchical name of the form x.y that is registered in the GameplayTagsManager You can filter the gameplay tags displayed in the editor.
    tag<native><public> := class<abstract> {}

    # A mutable collection of gameplay tags.
    tag_container<native><epic_internal> := class<concrete>(tag_view) {
      # Add the specified tag to the container.
      Add<native><epic_internal>(Tag: tag): void

      # Adds all the tags from one container to this container NOTE: From set theory, this effectively is the union of the container this is called on with TagsToAdd.
      Add<native><epic_internal>(TagsToAdd: []tag): void

      # Adds all the tags from one container to this container NOTE: From set theory, this effectively is the union of the container this is called on with TagsToAdd.
      Add<native><epic_internal>(TagsToAdd: tag_container): void

      @available { MinUploadedAtFNVersion := 2930 }
      # Returns a generator for the tags in this container. This is an expensive operation since it will create new tag instances for all tags in the container. Do preferably not use this function for anything else than debugging.
      GetTags<native><epic_internal>()<transacts>: generator(tag)

      # Determine if TagToCheck is present in this container, also checking against parent tags {"A.1"}.Has("A") will return True, {"A"}.Has("A.1") will return False If TagToCheck is not Valid it will always return False.
      Has<native><override>(TagToCheck: tag)<computes><decides><reads>: void

      # Checks if this container contains ALL of the tags in the specified container, also checks against parent tags {"A.1","B.1"}.HasAll({"A","B"}) will return True, {"A","B"}.HasAll({"A.1","B.1"}) will return False If InTags is empty/invalid it will always return True, because there were no failed checks.
      HasAll<native><epic_internal>(InTags: tag_container)<computes><decides><reads>: void

      # Checks if this container contains ALL of the tags in the specified container, also checks against parent tags {"A.1","B.1"}.HasAll({"A","B"}) will return True, {"A","B"}.HasAll({"A.1","B.1"}) will return False If InTags is empty/invalid it will always return True, because there were no failed checks.
      HasAll<native><override>(InTags: []tag)<computes><decides><reads>: void

      # Checks if this container contains ANY of the tags in the specified container, also checks against parent tags {"A.1"}.HasAny({"A","B"}) will return True, {"A"}.HasAny({"A.1","B"}) will return False If InTags is empty/invalid it will always return False.
      HasAny<native><epic_internal>(InTags: tag_container)<computes><decides><reads>: void

      # Checks if this container contains ANY of the tags in the specified container, also checks against parent tags {"A.1"}.HasAny({"A","B"}) will return True, {"A"}.HasAny({"A.1","B"}) will return False If InTags is empty/invalid it will always return False.
      HasAny<native><override>(InTags: []tag)<computes><decides><reads>: void

      # Returns the number of explicitly added tags.
      Num<native><epic_internal>()<computes><reads>: int

      # Remove the specified tag from the container.
      Remove<native><epic_internal>(Tag: tag)<decides>: void

      # Removes all tags in TagsToRemove from this container.
      Remove<native><epic_internal>(TagsToRemove: []tag): void

      # Removes all tags in TagsToRemove from this container.
      Remove<native><epic_internal>(TagsToRemove: tag_container): void

      # Remove all tags from the container. Will maintain slack by default.
      Reset<native><epic_internal>(): void

      # Remove all tags from the container. Update the amount of slack pre-allocated for tags.
      ResetWithSlack<native><epic_internal>(slack: int): void
    }

    # Advanced tag search criteria
    tag_search_criteria<native><public> := class {
      # Tags that may NOT be on the object. All items with these tags are excluded from the search.
      ExclusionTags<native><public>: []tag = external {}

      # Tags that are used if no required tags are specified. These are treated as if any of them will do.
      PreferredTags<native><public>: []tag = external {}

      # Tags required to be on the object.
      RequiredTags<native><public>: []tag = external {}

      # Flag to request sorting the results by tag.
      SortType<native><public>: tag_search_sort_type = external {}
    }

    tag_search_sort_type<native><public> := enum {
      Sorted

      Unsorted
    }

    @import_as("/Script/VerseGameplayTags.FVerseGameplayTag")
    # Utility structure which allows users to select a gameplay tag when exposed to editor
    tag_selector<native><epic_internal> := struct<concrete> {}

    @import_as("/Script/VerseGameplayTags.FVerseGameplayTagContainer")
    # Utility structure which allows users to select a gameplay tag when exposed to editor
    tag_selector_container<native><epic_internal> := struct<concrete> {}

    # A queryable collection of gameplay tags.
    tag_view<native><public> := interface<epic_internal> {
      # Determine if TagToCheck is present in this container, also checking against parent tags {"A.1"}.Has("A") will return True, {"A"}.Has("A.1") will return False If TagToCheck is not Valid it will always return False.
      Has<public>(TagToCheck: tag)<computes><decides><reads>: void

      # Checks if this container contains ALL of the tags in the specified container, also checks against parent tags {"A.1","B.1"}.HasAll({"A","B"}) will return True, {"A","B"}.HasAll({"A.1","B.1"}) will return False If InTags is empty/invalid it will always return True, because there were no failed checks.
      HasAll<public>(InTags: []tag)<computes><decides><reads>: void

      # Checks if this container contains ANY of the tags in the specified container, also checks against parent tags {"A.1"}.HasAny({"A","B"}) will return True, {"A"}.HasAny({"A.1","B"}) will return False If InTags is empty/invalid it will always return False.
      HasAny<public>(InTags: []tag)<computes><decides><reads>: void
    }
  }

  agent<native><public> := class<unique><epic_internal> {}

  @attribscope_class
  @attribscope_data
  @customattribhandler
  allow_self_reference<epic_internal> := class<computes>(attribute) {}

  category<constructor><epic_internal>(Category: string)<computes>: category_attribute = external {}

  @attribscope_class
  @attribscope_data
  @attribscope_function
  @customattribhandler
  category_attribute<epic_internal> := class<computes><internal>(attribute) {}

  clamp_max<constructor><epic_internal>(ClampMax: string)<computes>: clamp_max_attribute = external {}

  @attribscope_data
  @customattribhandler
  clamp_max_attribute<epic_internal> := class<computes><internal>(attribute) {}

  clamp_min<constructor><epic_internal>(ClampMin: string)<computes>: clamp_min_attribute = external {}

  @attribscope_data
  @customattribhandler
  clamp_min_attribute<epic_internal> := class<computes><internal>(attribute) {}

  display_name<constructor><epic_internal>(DisplayName: string)<computes>: display_name_attribute = external {}

  @attribscope_class
  @attribscope_data
  @attribscope_function
  @customattribhandler
  display_name_attribute<epic_internal> := class<computes><internal>(attribute) {}

  display_priority<constructor><epic_internal>(DisplayPriority: string)<computes>: display_priority_attribute = external {}

  @attribscope_class
  @attribscope_data
  @attribscope_function
  @customattribhandler
  display_priority_attribute<epic_internal> := class<computes><internal>(attribute) {}

  @attribscope_class
  @attribscope_struct
  @attribscope_data
  @customattribhandler
  editable<public> := class<computes>(attribute) {
    # The categories displayed in the editor.
    Categories<public>: []message = external {}

    EditInline<epic_internal>: logic = external {}

    # The short tooltip displayed in the editor.
    ShortToolTip<epic_internal>: message = external {}

    # The thumbnail shown in the content browser.
    ShowThumbnail<epic_internal>: logic = external {}

    # The tooltip displayed in the editor.
    ToolTip<public>: message = external {}
  }

  @attribscope_class
  @attribscope_struct
  @attribscope_data
  @customattribhandler
  editable_container<public> := class<final><computes>(editable) {
    # If true, allows reordering of the container elements in the editor.
    AllowReordering<public>: logic = external {}
  }

  editable_empty_message<localizes><epic_internal>: message = external {}

  @attribscope_class
  @attribscope_struct
  @attribscope_data
  @customattribhandler
  editable_non_concrete<epic_internal> := class<computes>(attribute) {
    EditInline<epic_internal>: logic = external {}
  }

  @attribscope_class
  @attribscope_struct
  @attribscope_data
  @customattribhandler
  editable_number<public>(t: type) := class<final><computes>(editable) {
    # The maximum value the editor allows.
    MaxValue<public>: ?t = external {}

    # The minimum value the editor allows.
    MinValue<public>: ?t = external {}

    # Snap the spinbox to the nearest delta.
    SpinBoxDelta<public>: ?t = external {}
  }

  @attribscope_class
  @attribscope_struct
  @attribscope_data
  @customattribhandler
  editable_slider<public>(t: type) := class<final><computes>(editable) {
    # The maximum value of the editor slider.
    MaxValue<public>: ?t = external {}

    # The minimum value of the editor slider.
    MinValue<public>: ?t = external {}

    # Used to change how sensitive the field value is when moving the slider via mouse cursor.
    MouseLinearDeltaSensitivity<public>: float = external {}

    MouseShiftMovePixelPerDelta<public>: float = external {}

    # The amount the slider moves for each step.
    SliderDelta<public>: ?t = external {}

    # Used to scale a slider exponentially. Common values are found within the range of 1-20.
    SliderExponent<public>: ?t = external {}
  }

  @attribscope_class
  @customattribhandler
  editable_subclass<epic_internal> := class<computes>(attribute) {}

  @attribscope_class
  @attribscope_struct
  @attribscope_data
  @customattribhandler
  editable_text_box<public> := class<final><computes>(editable) {
    # The maximum length of the text.
    MaxLength<public>: int = external {}

    # True if the editor text box should support multiple lines.
    MultiLine<public>: logic = external {}
  }

  @attribscope_class
  @attribscope_struct
  @attribscope_data
  @customattribhandler
  editable_vector_number<public>(t: type) := class<final><computes>(editable) {
    # The maximum value allowed for each vector element.
    MaxComponentValue<public>: ?t = external {}

    # The minimum value allowed for each vector element.
    MinComponentValue<public>: ?t = external {}

    # Show the button that allows normalizing the vector.
    ShowNormalize<public>: logic = external {}

    # Show the button that allows locking the vector aspect ratio.
    ShowPreserveRatio<public>: logic = external {}

    # Snap the spinbox to the nearest delta.
    SpinBoxDelta<public>: ?t = external {}
  }

  @attribscope_class
  @attribscope_struct
  @attribscope_data
  @customattribhandler
  editable_vector_slider<public>(t: type) := class<final><computes>(editable) {
    # The maximum value allowed for each vector element.
    MaxComponentValue<public>: ?t = external {}

    # The minimum value allowed for each vector element.
    MinComponentValue<public>: ?t = external {}

    # Used to change how sensitive the field value is when moving the slider via mouse cursor.
    MouseLinearDeltaSensitivity<public>: float = external {}

    MouseShiftMovePixelPerDelta<public>: float = external {}

    # Show the button that allows normalizing the vector.
    ShowNormalize<public>: logic = external {}

    # Show the button that allows locking the vector aspect ratio.
    ShowPreserveRatio<public>: logic = external {}

    # The amount the slider moves for each step.
    SliderDelta<public>: ?t = external {}

    # Used to scale a slider exponentially. Common values are found within the range of 1-20.
    SliderExponent<public>: ?t = external {}
  }

  @attribscope_class
  @attribscope_data
  @customattribhandler
  experimental_always_overridden<epic_internal> := class<computes>(attribute) {}

  @attribscope_class
  @customattribhandler
  hide_in_editor<epic_internal> := class<computes>(attribute) {}

  localizable_agent<native><epic_internal> := class(localizable_value) {
    Value<native><epic_internal>: agent
  }

  player<native><public> := class<unique><persistent><module_scoped_var_weak_map_key><epic_internal>(agent) {
    # Succeeds when this `player` may be used as a module-scoped `var` `weak_map` key. This coincides with the corresponding player having joined the game and not yet left. Using a `player` as a module-scope `var` `weak_map` key when this method fails results in a runtime error.
    IsActive<native><public>()<computes><decides><reads>: void
  }

  # Module import path: /Verse.org/Simulation/player_array_helper
  player_array_helper<epic_internal> := module {
    TestFunc<native><epic_internal>(new_value: int): int
  }

  player_multicast_delegate<native><epic_internal> := class<final>(multicast_delegate(player)) {}

  # Type for which there is a single instance per round.  Use `GetSession` to get the current round's `session` instance. May be used with `weak_map` to implement global variables.
  # Note: may be changed in a future release to a single instance per game. Round-local behavior should not be relied upon.
  session<native><public> := class<unique><module_scoped_var_weak_map_key><epic_internal> {}

  short_tool_tip<constructor><epic_internal>(ShortToolTip: string)<computes>: short_tool_tip_attribute = external {}

  @attribscope_class
  @attribscope_data
  @attribscope_function
  @customattribhandler
  short_tool_tip_attribute<epic_internal> := class<computes><internal>(attribute) {}

  team<native><public> := class<unique><epic_internal> {}

  tool_tip<constructor><epic_internal>(ToolTip: string)<computes>: tool_tip_attribute = external {}

  @attribscope_class
  @attribscope_data
  @attribscope_function
  @customattribhandler
  tool_tip_attribute<epic_internal> := class<computes><internal>(attribute) {}

  ui_max<constructor><epic_internal>(UIMax: string)<computes>: ui_max_attribute = external {}

  @attribscope_data
  @customattribhandler
  ui_max_attribute<epic_internal> := class<computes><internal>(attribute) {}

  ui_min<constructor><epic_internal>(UIMin: string)<computes>: ui_min_attribute = external {}

  @attribscope_data
  @customattribhandler
  ui_min_attribute<epic_internal> := class<computes><internal>(attribute) {}
}

Verse<public> := module {
  # Returns the first index whose element in `Input` equals `ElementToFind`.
  # Fails if ElementToFind does not exist in the array.
  (Input: []t where t: subtype(comparable)).Find<public>(ElementToFind: t)<computes><decides>: int = external {}

  # Makes an `array` by removing all elements that equal `ElementToRemove` from `Input`.
  (Input: []t where t: subtype(comparable)).RemoveAllElements<public>(ElementToRemove: t)<computes>: []t = external {}

  # Makes an `array` by removing the element at the lowest index that equals `ElementToRemove` from `Input`.
  # Fails if `Input` did not contain any instances of `ElementToRemove`.
  (Input: []t where t: subtype(comparable)).RemoveFirstElement<public>(ElementToRemove: t)<computes><decides>: []t = external {}

  # Makes an `array` by replacing all ranges of elements that equal `ElementsToReplace` with `Replacement` in `Input`.
  # When there are multiple overlapping instances of `ElementsToReplace` in `Input`, only the position with the lowest index is replaced.
  (Input: []t where t: subtype(comparable)).ReplaceAll<public>(
    ElementsToReplace: []t,
    Replacement: []t
  )<transacts>: []t = external {}

  # Makes an `array` by replacing all elements that equal `ElementToReplace` with `ElementToReplaceWith` in `Input`.
  (Input: []t where t: subtype(comparable)).ReplaceAllElements<public>(
    ElementToReplace: t,
    ElementToReplaceWith: t
  )<computes>: []t = external {}

  # Makes an `array` by replacing the element at the lowest index that equals `ElementToReplace` with `ElementToReplaceWith` in `Input`.
  # Fails if `Input` did not contain any instances of `ElementToReplace`.
  (Input: []t where t: subtype(comparable)).ReplaceFirstElement<public>(
    ElementToReplace: t,
    ElementToReplaceWith: t
  )<computes><decides>: []t = external {}

  # Makes an `array` by inserting `ElementsToInsert` into `Input` such that the first element of `ElementsToInsert` is at `InsertionIndex`.
  (Input: []t where t: type).Insert<public>(
    InsertionIndex: int,
    ElementsToInsert: []t
  )<computes><decides>: []t = external {}

  # Makes an `array` by removing `Input`'s elements from `StartIndex` to `StopIndex-1`.
  # Succeeds if `0 <= StartIndex <= StopIndex <= Input.Length`.
  (Input: []t where t: type).Remove<public>(StartIndex: int, StopIndex: int)<computes><decides>: []t = external {}

  # Makes an `array` by removing the element at `IndexToRemove` from `Input`.
  # Succeeds if `0 <= IndexToRemove <= Input.Length-1`.
  (Input: []t where t: type).RemoveElement<public>(IndexToRemove: int)<computes><decides>: []t = external {}

  # Makes an `array` by replacing the element at `IndexToReplace` with `ElementToReplaceWith` in `Input`.
  # Succeeds if `0 <= IndexToReplace <= Input.Length-1`.
  (Input: []t where t: type).ReplaceElement<public>(
    IndexToReplace: int,
    ElementToReplaceWith: t
  )<computes><decides>: []t = external {}

  # Makes an `array` containing `Input`'s elements from `StartIndex` to `Input.Length-1`.
  # Succeeds if `0 <= StartIndex <= Input.Length`.
  (Input: []t where t: type).Slice<public>(StartIndex: int)<computes><decides>: []t = external {}

  # Makes an `array` containing `Input`'s elements from `StartIndex` to `StopIndex-1`.
  # Fails unless `0 <= StartIndex <= StopIndex <= Input.Length`.
  (Input: []t where t: type).Slice<public>(StartIndex: int, StopIndex: int)<computes><decides>: []t = external {}

  # Succeeds if `Val` is within `AbsoluteTolerance` of `0.0`.
  (Val: float).IsAlmostZero<public>(AbsoluteTolerance: float)<computes><decides>: void = external {}

  # Returns `X` if `X` is finite.
  # Fails if `X` is one of:`
  #  * `+Inf`
  #  * `-Inf`
  #  * `NaN`
  (X: float).IsFinite<public>()<computes><decides>: float = external {}

  # Returns the inverse hyperbolic cosine of `X` if `1.0 <= X`.
  ArCosh<native><public>(X: float)<computes><reads>: float

  # Returns the inverse hyperbolic sine of `X` if `IsFinite(X)`.
  ArSinh<native><public>(X: float)<computes><reads>: float

  # Returns the inverse hyperbolic tangent of `X` if `IsFinite(X)`.
  ArTanh<native><public>(X: float)<computes><reads>: float

  # Returns the inverse cosine (arccosine) of `X` if `-1.0 <= X <= 1.0`.
  ArcCos<native><public>(X: float)<computes><reads>: float

  # Returns the inverse sine (arcsine) of `X` if `-1.0 <= X <= 1.0`.
  ArcSin<native><public>(X: float)<computes><reads>: float

  # Returns the inverse tangent (arctangent) of `X` such that:`-PiFloat/2.0 <= ArcTan(x) <= PiFloat/2.0`.
  ArcTan<native><public>(X: float)<computes><reads>: float

  # Returns the angle in radians at the origin between a ray pointing to `(X, Y)` and the positive `X` axis such that `-PiFloat < ArcTan(Y, X) <= PiFloat`.
  # Returns 0.0 if `X=0.0 and Y=0.0`.
  ArcTan<native><public>(Y: float, X: float)<computes><reads>: float

  # Returns the smallest `int` that is greater than or equal to `Val`.
  # Fails if `not IsFinite(Val)`.
  Ceil<native><public>(Val: float)<computes><decides><reads>: int

  # Constrains the value of `Val` between `A` and `B`. Robustly handles different argument orderings.
  # Returns the median of `Val`, `A`, and `B`.
  Clamp<native><public>(Val: int, A: int, B: int)<computes>: int

  # Constrains the value of `Val` between `A` and `B`. Robustly handles different argument orderings.
  # Returns the median of `Val`, `A`, and `B`, such that comparisons with `NaN` operate as if `NaN > +Inf`.
  Clamp<public>(Val: float, A: float, B: float)<computes>: float = external {}

  # Makes a flattened `array` by concatenating the elements of `Arrays`.
  Concatenate<public>(Arrays: [][]t where t: type)<computes>: []t = external {}

  # Returns the cosine of `X` if `IsFinite(X)`.
  # Returns `NaN` if `not IsFinite(X)
  Cos<native><public>(X: float)<computes><reads>: float

  # Returns the hyperbolic cosine of `X`.
  Cosh<native><public>(X: float)<computes><reads>: float

  # Halts the Verse runtime with error `Message`.
  Err<native><public>(Message: string)<computes>: false

  # Returns the natural exponent of `X`.
  Exp<native><public>(X: float)<computes><reads>: float

  # Returns the largest `int` that is less than or equal to `Val`.
  # Fails if `not IsFinite(Val)`.
  Floor<native><public>(Val: float)<computes><decides><reads>: int

  # Returns the number of seconds since January 1, 1970 UTC, ignoring leap seconds. I.e, this function implements Unix time. This function always returns the same value within the same transaction.
  GetSecondsSinceEpoch<native><public>()<computes><reads>: float

  # Returns the `int` that equals `Val` without the fractional part.
  # Fails if `not IsFinite(val)`.
  Int<native><public>(Val: float)<computes><decides><reads>: int

  # Succeeds if `Val1` and `Val2` are within `AbsoluteTolerance` of each other.
  IsAlmostEqual<public>(Val1: float, Val2: float, AbsoluteTolerance: float)<computes><decides>: void = external {}

  # Makes a `string` by concatenating `Separator` between the elements of `Strings`.
  Join<native><public>(Strings: []string, Separator: string)<computes>: string

  # Used to linearly interpolate/extrapolate between `From` (when `Parameter = 0.0`) and `To` (when `Parameter = 1.0`). Expects that all arguments are finite.
  # Returns `From*(1 - Parameter) + To*Parameter`.
  Lerp<native><public>(From: float, To: float, Parameter: float)<computes><reads>: float

  # Returns the natural logarithm of `X`.
  Ln<native><public>(X: float)<computes><reads>: float

  # Makes a `string` by localizing `Message` based on the current `locale`.
  Localize<native><public>(Message: message)<computes><reads>: string

  # Returns the base `B` logarithm of `X`.
  Log<public>(B: float, X: float)<computes><reads>: float = external {}

  MakeLocalizableValue<epic_internal>(V: float): localizable_float = external {}

  MakeLocalizableValue<epic_internal>(V: int): localizable_int = external {}

  MakeLocalizableValue<epic_internal>(V: message): localizable_message = external {}

  MakeLocalizableValue<epic_internal>(V: string): localizable_string = external {}

  MakeMessageInternal<native><epic_internal>(K: string, D: string, S: [string]localizable_value)<converges>: message

  # Returns the maximum of `X` and `Y` unless either are `NaN`.
  # Returns `NaN` if either `X` or `Y` are `NaN`.
  Max<public>(X: float, Y: float)<computes>: float = external {}

  # Returns the maximum of `X` and `Y`.
  Max<public>(X: int, Y: int)<computes>: int = external {}

  # Returns the minimum of `X` and `Y` unless either are `NaN`.
  # Returns `NaN` if either `X` or `Y` are `NaN`.
  Min<public>(X: float, Y: float)<computes>: float = external {}

  # Returns the minimum of `X` and `Y`.
  Min<public>(X: int, Y: int)<computes>: int = external {}

  # Returns the remainder of `X/Y` as defined by Euclidean division, i.e.:
  #  * `Mod[X,Y] = X - Quotient(X/Y)*Y`
  #  * `0 <= Mod[X,Y] < Abs(Y)`
  # Fails if `Y=0`.
  Mod<native><public>(X: int, Y: int)<computes><decides>: int

  # Pi, the ratio of the circumference of a circle to its diameter.
  PiFloat<public>: float = external {}

  # Returns `A` to the power of `B`.
  Pow<native><public>(A: float, B: float)<computes><reads>: float

  # Writes `Message` to a dedicated `Print` log while displaying it in `Color` on the client screen for `Duration` seconds. By default, `Color` is `NamedColors.White` and `Duration` is `2.0` seconds.
  Print<native><public>(Message: message, ?Duration: float = external {}, ?Color: color = external {})<transacts>: void

  using { /Verse.org/Colors }
  # Writes `Message` to a dedicated `Print` log while displaying it in `Color` on the client screen for `Duration` seconds. By default, `Color` is `NamedColors.White` and `Duration` is `2.0` seconds.
  Print<native><public>(Message: string, ?Duration: float = external {}, ?Color: color = external {})<transacts>: void

  # Returns the quotient `X/Y` as defined by Euclidean division, i.e.:
  #  * `Quotient[X/Y] = Floor[X/Y]` when `Y > 0`
  #  * `Quotient[X/Y] = Ceil[X/Y]` when `Y < 0`
  #  * `Quotient[X/Y] * Y + Mod[X,Y] = X`
  # Fails if `Y = 0`.
  Quotient<native><public>(X: int, Y: int)<computes><decides>: int

  # Returns `Val` rounded to the nearest `int`. When the fractional part of `Val` is `0.5`, rounds to the nearest *even* `int` (per the IEEE-754 default rounding mode).
  # Fails if `not IsFinite(Val)`.
  Round<native><public>(Val: float)<computes><decides><reads>: int

  # Returns the sign of `Val`:
  #  * `1.0` if `Val > 0.0`
  #  * `0.0` if `Val = 0.0`
  #  * `-1.0` if `Val < 0.0`
  #  * `NaN` if `Val = NaN`
  Sgn<public>(Val: float)<computes>: float = external {}

  # Returns the sign of `Val`:
  #   * `1` if `Val > 0`
  #  * `0` if `Val = 0`
  #  * `-1` if `Val < 0`
  Sgn<public>(Val: int)<computes>: int = external {}

  # Returns the sine of `X` if `IsFinite(X)`.
  # Returns `NaN` if `not IsFinite(X)
  Sin<native><public>(X: float)<computes><reads>: float

  # Returns the hyperbolic sine of `X`.
  Sinh<native><public>(X: float)<computes><reads>: float

  # Returns the square root of `X` if `X >= 0.0`.
  # Returns `NaN` if `X < 0.0`.
  Sqrt<native><public>(X: float)<computes><reads>: float

  # Returns the tangent of `X` if `IsFinite(X)`.
  # Returns `NaN` if `not IsFinite(X).
  Tan<native><public>(X: float)<computes><reads>: float

  # Returns the hyperbolic tangent of `X`.
  Tanh<native><public>(X: float)<computes><reads>: float

  # Makes a `string` by converting `Character` to UTF-8 from UTF-32.
  ToString<native><epic_internal>(Character: char32)<computes>: string

  # Makes a `string` from `Character`.
  ToString<native><public>(Character: char)<computes>: string

  # Makes a `string` representation of `Val`.
  ToString<native><public>(Val: float)<computes><reads>: string

  # Makes a printable `string` representation of `Val`.
  ToString<native><public>(Val: int)<computes>: string

  # Returns `String` without modification.
  ToString<public>(String: string)<computes>: string = external {}

  accessor<epic_internal> := enum {
    Dummy
  }

  # Implemented by classes that allow users to cancel an operation. For example, calling `subscribable.Subscribe` with a callback returns a `cancelable` object. Calling `Cancel` on the return object unsubscribes the callback.
  cancelable<native><public> := interface {
    # Prevents any current or future work from completing.
    Cancel<public>()<transacts>: void
  }

  # Implemented by classes whose instances have limited lifetimes.
  disposable<native><public> := interface {
    # Cleans up this object.
    Dispose<public>(): void
  }

  # Implemented by classes whose instances can be enabled and disabled.
  enableable<native><public> := interface<epic_internal> {
    # Disable this object.
    Disable<public>(): void

    # Enable this object.
    Enable<public>(): void

    # Succeeds if the object is enabled, fails if its disabled.
    IsEnabled<public>()<transacts><decides>: void
  }

  # A *recurring*, successively signaled parametric `event` with a `payload` allowing a simple mechanism to coordinate between concurrent tasks:
  #  * `Await` suspends tasks to wait on this `event`,
  #  * another task `Signal`s this `event` and resumes the suspended tasks in FIFO order.
  event<native><public>(t: type) := class(signalable(t), awaitable(t)) {
    # Suspends the current task until another task calls `Signal`.
    # If called during another invocation of `Signal`, the the task will still suspend and resume during the next call to `Signal`.
    Await<native><override>()<suspends>: t

    # Returns the number of suspended tasks added by calls to `Await` that have not been resumed by a call to `Signal`.
    GetAwaitCount<native><epic_internal>(): int

    # Concurrently resumes the tasks that were suspended by `Await` calls before this call to `Signal`.
    #
    # Tasks are resumed in the order they were suspended. Each task will perform as much work as it can until it encounters a blocking call, whereupon it will transfer control to the next suspended task.
    Signal<native><override>(Val: t): void
  }

  # A *recurring*, successively signaled event allowing a simple mechanism to coordinate between concurrent tasks.
  event<public>() := event(tuple())

  # Implemented by classes whose instances can become invalid at runtime.
  invalidatable<native><public> := interface(disposable) {
    # Succeeds if this object is still valid.
    IsValid<public>()<transacts><decides>: void
  }

  # A parameterless interface combining `awaitable` and `subscribable`.
  listenable<public>() := listenable(tuple())

  # A parametric interface combining `awaitable` and `subscribable`.
  listenable<public>(payload: type) := interface(awaitable(payload), subscribable(payload)) {}

  # Used for message localization.
  locale<native><public> := struct<epic_internal> {}

  localizable_float<native><epic_internal> := class<internal>(localizable_value) {}

  localizable_int<native><epic_internal> := class<internal>(localizable_value) {}

  localizable_message<native><epic_internal> := class<internal>(localizable_value) {}

  localizable_string<native><epic_internal> := class<internal>(localizable_value) {}

  localizable_value<native><epic_internal> := class {}

  # A localizable text message.
  message<native><public> := class<epic_internal> {
    DefaultText<native><epic_internal>: string

    Key<native><epic_internal>: string

    Substitutions<native><epic_internal>: [string]localizable_value
  }

  # A parametric interface implemented by events with a `payload` that can be signaled.
  # Can be used with `awaitable`, `subscribable`, or both (see: `listenable`).
  signalable<public>(payload: type) := interface {
    # Concurrently resumes the tasks waiting for this event in `awaitable.Await` and synchronously invokes any callbacks added to this event by `subscribable.Subscribe`.
    Signal<native_callable><public>(Val: payload): void
  }

  # A parameterless interface implemented by events that can be subscribed to.
  subscribable<public>() := subscribable(tuple())

  # A parametric interface implemented by events with a `payload` that can be subscribed to.
  # Matched with `signalable.`
  subscribable<public>(t: type) := interface {
    # Registers `Callback` to be invoked on matching calls to `signable.Signal`.
    # Returns an unsubscriber object. Call `cancelable.Cancel` on the unsubscriber to unregister `Callback`.
    Subscribe<public>(Callback: type { __(: t): void })<transacts>: cancelable
  }
}

using { /Verse.org/VerseEngine/Component }
# Module import path: /Verse.org/VerseEngine
VerseEngine<public> := module {
  # Module import path: /Verse.org/VerseEngine/Component
  Component<public> := module {
    @import_as("/Script/EntityCore.UEntityComponent")
    vk_component<native><public> := class<abstract> {}
  }

  # Module import path: /Verse.org/VerseEngine/Entity
  Entity<public> := module {
    # Module import path: /Verse.org/VerseEngine/Entity/EntityHelpers
    EntityHelpers<public> := module {
      # Destroy the vk_entity the vk_component is attached to
      DestroyObject<native><public>(__dupe___unnamed_parameter_29: vk_component): logic

      # Get a vk_component from the vk_entity of the specified type
      GetComponentOfTypeC<native><public>(InComponent: vk_component, Type: type)<transacts><decides>: vk_component

      # Gets the vk_entity associated with the parameter provided vk_component
      GetEntityFromComponent<native><public>(__dupe___unnamed_parameter_30: vk_component)<transacts><decides>: vk_entity
    }

    vk_entity<native><public> := class<final> {
      # Add a vk_component to the vk_entity of the specified type
      AddComponent<native><public>(ComponentType: type)<transacts>: ?vk_component

      # Destroy the vk_entity
      Destroy<native><public>(): logic

      # Helper method for ensuring components exist, creating them if they don't exist
      EnsureComponents<public>(AddComponentClasses: []subtype(vk_component)): void = external {}

      # Get all vk_component(s) from the vk_entity of the specified type
      GetAllComponentsOfType<native><public>(ComponentType: type)<transacts>: []vk_component

      # Get a vk_component from the vk_entity of the specified type
      GetComponentOfType<native><public>(ComponentType: type)<transacts>: ?vk_component

      GetFullname<native><public>(): string

      GetName<native><public>(): string

      # Get a vk_component from the vk_entity of the specified type, if one does not exist, add it
      GetOrCreateComponentOfType<native><public>(ComponentType: type): ?vk_component

      # Helper method for check if required components exist
      HasComponents<public>(RequiredComponentClasses: []subtype(vk_component))<transacts><decides>: void = external {}

      # Compare with another vk_entity
      IsEqual<native><public>(OtherEntity: vk_entity)<transacts>: logic

      # Remove a vk_component from the vk_entity
      RemoveComponent<native><public>(__dupe___unnamed_parameter_20: vk_component): logic
    }
  }

  float_param_delegate_signature<public> := type { __(: float): void }

  int_param_delegate_signature<public> := type { __(: int): void }

  logic_param_delegate_signature<public> := type { __(: logic): void }

  multicast_delegate<native><public>(t: type) := class(multicast_delegate_base, subscribable(t)) {
    Broadcast<native><public>(__dupe___unnamed_parameter_32: t): void

    Empty<native><public>(): void

    Subscribe<native><override>(Callback: type { __(: t): void })<transacts>: cancelable
  }

  multicast_delegate<public>() := multicast_delegate(tuple())

  multicast_delegate_base<native><public> := class {}

  no_param_delegate_signature<public> := type { __(): void }

  string_param_delegate_signature<public> := type { __(: string): void }

  subscribable_event<epic_internal>() := subscribable_event(tuple())

  subscribable_event<native><epic_internal>(t: type) := class(multicast_delegate(t), listenable(t)) {
    Await<native><override>()<suspends>: t

    Broadcast<native><override>(__dupe___unnamed_parameter_33: t): void
  }
}